from random import randint, random
import matplotlib.pyplot as plt
import numpy as np
# ---------------- GA primitives ----------------

def individual(length, min_val, max_val):
    return [randint(min_val, max_val) for _ in range(length)]

def population(count, length, min_val, max_val):
    return [individual(length, min_val, max_val) for _ in range(count)]

def fitness(individual, target_coeffs):
    # average absolute coefficient error (lower is better)
    return sum(abs(a - b) for a, b in zip(individual, target_coeffs)) / len(target_coeffs)

def grade(pop, target_coeffs):
    return sum(fitness(x, target_coeffs) for x in pop) / len(pop)

# ---------------- Selection ----------------

def tournament_select(pop, target_coeffs, k=3):
    """Pick best from k random contestants."""
    best = None
    best_fit = float('inf')
    n = len(pop)
    for _ in range(k):
        cand = pop[randint(0, n - 1)]
        f = fitness(cand, target_coeffs)
        if f < best_fit:
            best_fit = f
            best = cand
    return best[:]

def rank_select(pop, target_coeffs, bias=1.5):
    """
    Select one individual using rank-based selection.
    bias > 1 gives higher rank more chance; bias=1 gives uniform chance.
    """
    fits = np.array([fitness(ind, target_coeffs) for ind in pop])
    ranked = np.argsort(fits)  # ascending: best is rank 0
    N = len(pop)
    # Assign ranks: rank 0 to best individual, rank N-1 to worst
    # Linear bias (default): probability for rank k is proportional to bias - (bias-1)*k/(N-1)
    probs = np.array([bias - (bias-1)*k/(N-1) for k in range(N)])
    probs = probs / probs.sum()
    idx = np.random.choice(N, p=probs)
    return pop[ranked[idx]][:]


def roulette_select(pop, target_coeffs):
    # Calculate fitness for each individual
    fits = np.array([fitness(ind, target_coeffs) for ind in pop])
    # Invert fitness: lower values should get higher probability
    # Add a small epsilon to avoid division by zero
    epsilon = 1e-8
    inverted = 1.0 / (fits + epsilon)
    probs = inverted / inverted.sum()
    idx = np.random.choice(len(pop), p=probs)
    return pop[idx][:]

# ---------------- Crossover ----------------

def one_point_crossover(p1, p2):
    L = len(p1)
    cut = randint(1, L - 1) if L > 1 else 0
    c1 = p1[:cut] + p2[cut:]
    c2 = p2[:cut] + p1[cut:]
    return c1, c2

def two_point_crossover(p1, p2):
    L = len(p1)
    if L < 3:
        # fallback to one-point
        cut = randint(1, L - 1) if L > 1 else 0
        return p1[:cut] + p2[cut:], p2[:cut] + p1[cut:]
    a = randint(1, L - 2)
    b = randint(a + 1, L - 1)
    c1 = p1[:a] + p2[a:b] + p1[b:]
    c2 = p2[:a] + p1[a:b] + p2[b:]
    return c1, c2

# ---------------- Evolution (pure GA) ----------------

def evolve(pop, target_coeffs,
           min_val=-100, max_val=100,
           elitism=2,  # keep top-k unchanged
           tournament_k=3, 
           selection_method='tournament',
           crossover_method='two_point',
           pc=0.8,     # crossover probability
           pm=0.01, # per-gene mutation probability
           bias=1.5  # only used if selection_method='rank'
           ):
    # Elitism
    ranked = sorted(pop, key=lambda x: fitness(x, target_coeffs))
    elites = [ind[:] for ind in ranked[:elitism]]

    # Generate rest using selection + crossover + mutation
    next_pop = elites[:]
    N = len(pop)
    while len(next_pop) < N:
        if selection_method == 'tournament':
            p1 = tournament_select(pop, target_coeffs, k=tournament_k)
            p2 = tournament_select(pop, target_coeffs, k=tournament_k)
        elif selection_method == 'roulette':
            p1 = roulette_select(pop, target_coeffs)
            p2 = roulette_select(pop, target_coeffs)
        elif selection_method == 'rank':
            p1 = rank_select(pop, target_coeffs, bias=1.0)
            p2 = rank_select(pop, target_coeffs, bias=1.0)
        else:
            raise ValueError(f"Invalid selection method: {selection_method}")

        # crossover
        if random() < pc:
            if crossover_method == 'one_point':
                c1, c2 = one_point_crossover(p1, p2)
            elif crossover_method == 'two_point':
                c1, c2 = two_point_crossover(p1, p2)
        else: # no crossover
            c1, c2 = p1[:], p2[:]
            

        # mutation (random reset)
        for g in range(len(c1)):
            if random() < pm:
                c1[g] = randint(min_val, max_val)
        for g in range(len(c2)):
            if random() < pm:
                c2[g] = randint(min_val, max_val)

        # append
        if len(next_pop) < N:
            next_pop.append(c1)
        if len(next_pop) < N:
            next_pop.append(c2)

    # exact size
    return next_pop[:N]

# ---------------- Parameter Sweep and Plotting ----------------

def generations_to_solution(target_coeffs, N, pc, pm, max_generations,
                            elitism=4, k=3, step=1, coeff_min=-100, coeff_max=100, genome_len=6):
    pop = population(N, genome_len, coeff_min, coeff_max)
    for gen in range(max_generations):
        best = min(pop, key=lambda x: fitness(x, target_coeffs))
        if fitness(best, target_coeffs) == 0.0:
            return gen
        pop = evolve(pop, target_coeffs,
                     min_val=coeff_min, max_val=coeff_max,
                     elitism=elitism, tournament_k=k,
                     pc=pc, pm=pm)
    return max_generations  # cap if not solved

def sweep_mutation_rates(target_coeffs,
                         mutation_rates,
                         trials=10,
                         N=150, pc=0.80, max_generations=350,
                         elitism=4, k=3, 
                         coeff_min=-100, coeff_max=100, genome_len=6):
    means, stds, solve_rates = [], [], []
    for pm in mutation_rates:
        gens = []
        for _ in range(trials):
            g = generations_to_solution(target_coeffs, N=N, pc=pc, pm=pm, max_generations=max_generations,
                                        elitism=elitism, k=k,
                                        coeff_min=coeff_min, coeff_max=coeff_max, genome_len=genome_len)
            gens.append(g)
        arr = np.array(gens, dtype=int)
        means.append(arr.mean())
        stds.append(arr.std(ddof=1))
        solve_rates.append((arr < max_generations).mean())
        print(f"pm={pm:.3f} | mean={arr.mean():.1f}, std={arr.std(ddof=1):.1f}, solve_rate={100*solve_rates[-1]:.0f}%")
    return np.array(means), np.array(stds), np.array(solve_rates)


def plot_mutation_sweep(mutation_rates, means, stds,
                        fixed_pc=0.80, fixed_N=150, trials=12, max_generations=350):
    plt.figure(figsize=(8.5,5))
    plt.errorbar(mutation_rates, means, yerr=stds, fmt='-o', capsize=4, linewidth=1.6,
                 label=f'pc={fixed_pc}, Population={fixed_N}, Trials={trials}, Cap={max_generations}')
    plt.xlabel('Mutation rate (pm)')
    plt.ylabel('Mean generations to exact solution')
    plt.title('Effect of Mutation Rate on GA Convergence')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.show()

def sweep_crossover_rates(target_coeffs,
                          crossover_rates,
                          trials=10,
                          N=150, pm=0.01, max_generations=1000,
                          elitism=1, k=3,
                          coeff_min=-100, coeff_max=100, genome_len=6):
    means, stds, solve_rates = [], [], []
    for pc in crossover_rates:
        gens = []
        for _ in range(trials):
            g = generations_to_solution(target_coeffs, N=N, pc=pc, pm=pm, max_generations=max_generations,
                                        elitism=elitism, k=k,
                                        coeff_min=coeff_min, coeff_max=coeff_max, genome_len=genome_len)
            gens.append(g)
        arr = np.array(gens, dtype=int)
        means.append(arr.mean())
        stds.append(arr.std(ddof=1))
        solve_rates.append((arr < max_generations).mean())
        print(f"pc={pc:.2f} | mean={arr.mean():.1f}, std={arr.std(ddof=1):.1f}, solve_rate={100*solve_rates[-1]:.0f}%")
    return np.array(means), np.array(stds), np.array(solve_rates)

def plot_crossover_sweep(crossover_rates, means, stds,
                         fixed_pm=0.01, fixed_N=100, trials=12, max_generations=1000):
    plt.figure(figsize=(8.5,5))
    plt.errorbar(crossover_rates, means, yerr=stds, fmt='-o', capsize=4, linewidth=1.6,
                 label=f'pm={fixed_pm}, Population={fixed_N}, Trials={trials}, Cap={max_generations}')
    plt.xlabel('Crossover probability (pc)')
    plt.ylabel('Mean generations to exact solution')
    plt.title('Effect of Crossover Probability on GA Convergence')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.show()


def sweep_population_sizes(target_coeffs,
                           pop_sizes,
                           trials=10,
                           pc=0.80, pm=0.1, max_generations=350,
                           elitism=4, k=3,
                           coeff_min=-100, coeff_max=100, genome_len=6):
    means, stds, solve_rates = [], [], []
    for N in pop_sizes:
        gens = []
        for _ in range(trials):
            g = generations_to_solution(target_coeffs, N=N, pc=pc, pm=pm, max_generations=max_generations,
                                        elitism=elitism, k=k, 
                                        coeff_min=coeff_min, coeff_max=coeff_max, genome_len=genome_len)
            gens.append(g)
        arr = np.array(gens, dtype=int)
        means.append(arr.mean())
        stds.append(arr.std(ddof=1))
        solve_rates.append((arr < max_generations).mean())
        print(f"Population ={N} | Mean={arr.mean():.1f}, Standard Deviation={arr.std(ddof=1):.1f}, Solve Rate={100*solve_rates[-1]:.0f}%")
    return np.array(means), np.array(stds), np.array(solve_rates)

def plot_population_sweep(pop_sizes, means, stds,
                          fixed_pm=0.01, fixed_pc=0.80, trials=12, max_generations=350):
    plt.figure(figsize=(8.5,5))
    plt.errorbar(pop_sizes, means, yerr=stds, fmt='-o', capsize=4, linewidth=1.6,
                 label=f'pm={fixed_pm}, pc={fixed_pc}, Trials={trials}, Cap={max_generations}')
    plt.xlabel('Population size (N)')
    plt.ylabel('Mean generations to exact solution')
    plt.title('Effect of Population Size on GA Convergence')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.show()


def plot_all_sweeps(mutation_rates, means_pm, std_pm,
                   crossover_rates, means_pc, std_pc,
                   pop_sizes, means_N, std_N,
                   trials=12, max_generations=800):
    """Plot mutation, crossover, and population sweeps in one figure."""
    fig, axes = plt.subplots(1, 3, figsize=(18, 5), constrained_layout=True)
    
    # Mutation rate sweep
    axes[0].errorbar(mutation_rates, means_pm, yerr=std_pm, fmt='-o', capsize=4, linewidth=1.6)
    axes[0].set_xlabel('Mutation rate (pm)')
    axes[0].set_ylabel('Mean generations to exact solution')
    axes[0].set_title('Effect of Mutation Rate')
    axes[0].grid(True, alpha=0.3)
    
    # Crossover rate sweep
    axes[1].errorbar(crossover_rates, means_pc, yerr=std_pc, fmt='-o', capsize=4, linewidth=1.6, color='tab:orange')
    axes[1].set_xlabel('Crossover probability (pc)')
    axes[1].set_ylabel('Mean generations to exact solution')
    axes[1].set_title('Effect of Crossover Probability')
    axes[1].grid(True, alpha=0.3)
    
    # Population size sweep
    axes[2].errorbar(pop_sizes, means_N, yerr=std_N, fmt='-o', capsize=4, linewidth=1.6, color='tab:green')
    axes[2].set_xlabel('Population size (N)')
    axes[2].set_ylabel('Mean generations to exact solution')
    axes[2].set_title('Effect of Population Size')
    axes[2].grid(True, alpha=0.3)
    
    plt.suptitle(f'GA Parameter Sweeps (Trials={trials}, Cap={max_generations})', fontsize=14, y=1.02)
    plt.show()


# # Then in your main section, replace the three separate plot calls with:
# if __name__ == '__main__':
#     target_coefficients = [25, 18, 31, -14, 7, -19]
    
#     mutation_rates  = [0, 0.01, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 0.90, 1]
#     crossover_rates = [0, 0.01, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 0.90, 1]
#     pop_sizes = list(range(10, 241, 20))
    
#     # Run sweeps
#     means_pm, std_pm, rate_pm = sweep_mutation_rates(
#         target_coeffs=target_coefficients,
#         mutation_rates=mutation_rates,
#         trials=12, N=150, pc=0.80, max_generations=800,
#         elitism=4, k=3
#     )
    
#     means_pc, std_pc, rate_pc = sweep_crossover_rates(
#         target_coeffs=target_coefficients,
#         crossover_rates=crossover_rates,
#         trials=12, N=150, pm=0.1, max_generations=800,
#         elitism=4, k=3
#     )
    
#     means_N, std_N, rate_N = sweep_population_sizes(
#         target_coeffs=target_coefficients,
#         pop_sizes=pop_sizes,
#         trials=12, pc=0.80, pm=0.1, max_generations=800,
#         elitism=4, k=3
#     )
    
    # # Plot all three in one figure
    # plot_all_sweeps(mutation_rates, means_pm, std_pm,
    #                crossover_rates, means_pc, std_pc,
    #                pop_sizes, means_N, std_N,
    #                trials=12, max_generations=800)


if __name__ == '__main__':
    target_coefficients = [25, 18, 31, -14, 7, -19]

    # Arrays to test 
    mutation_rates  = [0, 0.01, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 0.90, 1]
    crossover_rates = [0, 0.01, 0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60, 0.80, 0.90, 1]

    pop_sizes = list(range(10, 241, 20))

    # Use your existing mutation sweep
    # means_pm, std_pm, rate_pm = sweep_mutation_rates(
    #     target_coeffs=target_coefficients,
    #     mutation_rates=mutation_rates,
    #     trials=12, N=150, pc=0.80, max_generations=800,
    #     elitism=4, k=3
    # )
    # plot_mutation_sweep(mutation_rates, means_pm, std_pm)

    # Crossover sweep
    means_pc, std_pc, rate_pc = sweep_crossover_rates(
        target_coeffs=target_coefficients,
        crossover_rates=crossover_rates,
        trials=12, N=100, pm=0.1, max_generations=1000,
        elitism=4, k=3
    )
    plot_crossover_sweep(crossover_rates, means_pc, std_pc, max_generations=1000)

    # # Population size sweep
    # means_N, std_N, rate_N = sweep_population_sizes(
    #     target_coeffs=target_coefficients,
    #     pop_sizes=pop_sizes,
    #     trials=12, pc=0.80, pm=0.1, max_generations=800,
    #     elitism=4, k=3
    # )
    # plot_population_sweep(pop_sizes, means_N, std_N)

# -----------------------------------------------------------------
    

# if __name__ == '__main__':
#     target_coefficients = [25, 18, 31, -14, 7, -19]

#     p_count = 150          # larger population improves recombination
#     genome_len = 6
#     coeff_min, coeff_max = -100, 100
#     generations = 300

#     # GA parameters (pure GA)
#     elitism = 4
#     tournament_k = 3
#     pc = 0.9
#     pm = 0.12   # per-gene mutation prob
#     selection_method = 'tournament'  # 'tournament', 'roulette', 'rank'
#     bias = 1.0  # only used if selection_method='rank'
#     crossover_method = 'one_point'  # 'one_point', 'two_point'
#     early_stop_fraction = 1.0  # stop if this fraction of pop hits target
#     stagnate_generations = 20  # stop if no improvement for this many generations

#     pop = population(p_count, genome_len, coeff_min, coeff_max)
#     fitness_history = [grade(pop, target_coefficients)]
#     best_history = []
#     recent_fitness = []

#     solved = False
#     for gen in range(generations):
#         best = min(pop, key=lambda x: fitness(x, target_coefficients))
#         best_fit = fitness(best, target_coefficients)
#         best_history.append(best_fit)

#         # Early stop on exact match
#         if best_fit == 0.0:
#             solved = True
#             print(f"[SUCCESS] Found exact coefficients at gen {gen}: {best}, average={fitness_history[-1]:.3f}, best={best_fit:.3f}")
#             break
#     #   # Early stop checks on current population
#     #     zero_hits = sum(1 for ind in pop if fitness(ind, target_coefficients) == 0)
#     #     if zero_hits >= max(1, int(early_stop_fraction * p_count)):
#     #         print(f"Early stop at generation {gen}: {zero_hits}/{p_count} exact solutions.")
#     #         break
#         # Stagnation check
#         # recent_fitness.append(fitness_history)
#         # if len(recent_fitness) > stagnate_generations:
#         #     recent_fitness.pop(0)
#         # if all(f == recent_fitness[0] for f in recent_fitness):
#         #     print(f"Stopping due to stagnation at generation {gen} with fitness {fitness_history[-1]}.")
#         #     break 

#         pop = evolve(pop, target_coefficients,
#                      min_val=coeff_min, max_val=coeff_max,
#                      pc=pc, pm=pm, elitism=elitism, tournament_k=tournament_k, selection_method=selection_method, bias=bias)
#         fitness_history.append(grade(pop, target_coefficients))

#         if (gen + 1) % 20 == 0:
#             print(f"Gen {gen+1}: best={best_fit:.3f}, avg={fitness_history[-1]:.3f}")

#     if not solved:
#         best = min(pop, key=lambda x: fitness(x, target_coefficients))
#         print(f"No exact solution in {generations} generations.")
#         print(f"Best: {best}, fitness={fitness(best, target_coefficients):.3f}, average={fitness_history[-1]:.3f}")

#     # Plot
#     plt.figure(figsize=(9,5))
#     plt.plot(fitness_history, label='Average Fitness', lw=1.2)
#     plt.plot(best_history, label='Best Fitness', lw=1.6)
#     plt.xlabel('Generation'); plt.ylabel('Avg Abs Error per Coefficient')
#     plt.title(f'GA for Coefficients using {selection_method} selection (pop={p_count})')
#     plt.grid(True, alpha=0.3); plt.legend()
#     plt.show()
